---
title: "Data Transformation"
author: "Michael Kistner"
date: "May 16, 2022"
output: 
  html_document:
    toc: true
---

```{r echo=FALSE}
options(scipen = 999)
```

# Introduction

So far, we've been working with a single dataset at a time and modifying it in various ways. One of the most common tasks in data cleaning and management, however, is **merging** data -- combining data from two or more datasets into a single dataframe for analysis. In this notebook, we'll cover the family of `_join()` verbs from the **dplyr** package. Broadly speaking, these verbs can be classified into two categories: **mutating joins** (joins that add new variables to a dataset) and **filtering joins** (joins that filter rows according to the presence or absence of matches in a dataset). We'll begin by working with simple examples before moving to a real application of these principles. In addition to the `_join()` commands, we'll also cover the subject of reshaping data using the `pivot_longer()` and `pivot_wider()` commands from the **tidyr** package, which is useful when the data is XXXXXXXXXXXX.

As before, let's load the **tidyverse** package and get started.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
```

# Merging with _join() commands

Let's begin by creating a pair of small toy datasets to illustrate the logic of joins. Later on in the notebook we'll apply what we learn here to actual data. Suppose we have a dataset with details about members of Congress -- their first name, last name, their party, the state they're from, etc. Suppose we also have a separate dataset with information about the DW-NOMINATE scores for each member, representing their ideology on a scale that runs from approximately -1 (most liberal) to 1 (most conservative).^[A more detailed description of DW-NOMINATE scores and downloadable data can be found at [voteview.com](https://voteview.com/).] Let's call the first dataframe `df_a` (Dataframe A) and the second `df_b` (Dataframe B).
 
```{r}
df_a <- tibble(
  LastName = c("Pelosi", "McCarthy", "Ocasio-Cortez", 
               "Lee", "Crenshaw"),
  FirstName = c("Nancy", "Kevin", "Alexandria",
                "Barbara", "Dan"),
  Party = c("D", "R", "D", "D", "R"),
  State = c("CA", "CA", "NY", "CA", "TX")
)

df_b <- tibble(
  LastName = c("Schiff", "Pelosi", "Ocasio Cortez", 
               "Lee", "Crenshaw", "McCarthy", "Gaetz"),
  DWNom_Dim1 = c(-0.35, -0.49, -0.25, -0.68,
                 0.43, 0.46, 0.61)
)
```

With data this small, we could manually enter data from `df_b` into `df_a`, but with large datasets this quickly becomes impractical. Instead, we can use **dplyr**'s `_join()` commands to do the difficult work for us.

An important concept for all `_join()` commands is the idea of a **key**. A **key** variable identifies observations in each dataset. For example, in our dataframes, we could use `LastName` as the key variable to link observations across the two dataframes and combine them. 

There are some important details to know about using keys for merging. First, computers are literal machines. Keys have to match *exactly*. Spelling errors, different formatting, lower case vs. upper case -- any of these will result in the data with the non-matching keys not being merged. Second, not just the values of the key variable but the names of the key variable should be the same in each dataset. We need to tell the `_join()` commands what the name of the key variable is, and it should match in both dataframes.^[There actually is a way to get around this in the optional arguments of the `_join()` commands, but I find that it's usually easier to just make sure key variable names are identical before attempting to merge.] Third, if a single variable doesn't uniquely identify observations, multiple variables can be used. We'll come back to this last point in a bit.

Let's begin with the simplest version of the `_join()` commands, the `inner_join()`. An `inner_join()` merges two dataframes -- every column from dataframe A, and every column from dataframe B -- keeping only rows where there's a match between the key in dataframe A and dataframe B. This last fact is what makes the join and *inner* join. In set theoretic terms, it's the intersection of the two dataframes. Let's try combining our dataframes with an `inner_join()`.

```{r}
inner_join(df_a, df_b, by = "LastName")
```

What were the results? We now have a dataframe with all of the original variables in dataframe A (FirstName, Party, and State) along with the DW-NOMINATE scores for each representative. Notice, however, that we're missing some observations. First, (Adam) Schiff and (Matt) Gaetz are missing because even though they're in dataframe B, they're not in dataframe A. The `inner_join()` gets rid of these observations. 

Second, we're missing Alexandria Ocasio-Cortez even though she's in both datasets. If you take a look, you'll realize that the hyphen between AOC's last names is missing in her name in dataframe B. If we fix that, we'll get her data back in the merge.

```{r}
df_b <- mutate(df_b,
               LastName = ifelse(LastName == "Ocasio Cortez",
                                 "Ocasio-Cortez",
                                 LastName))

inner_join(df_a, df_b, by = "LastName")
```
Now that the name matches, the merge works as expected. 

Rarely in practice do we (or should we) use `inner_join()`, however. The tendency for `inner_join()` to throw away data when an exact match in the key variable isn't found means that we're likely to get rid of data unknowningly. When datasets are large, it will be difficult to catch issues caused by minor spelling discrepancies, such as the above. An alternative is `full_join()`, which returns all rows from both Dataframe A and Dataframe B regardless of if there's a key match or not.^[Again, in set theoretic terms this would be the union of the two dataframes.] In the case that there isn't, the variables from the dataframe with the missing key match will be returned as NA. For our example, it would look something like this:

```{r}
full_join(df_a, df_b, by = "LastName")
```

In this example, we now know that observations for Adam Schiff and Matt Gaetz are missing from Dataframe A. If we weren't expecting that, we can then investigate. 

So far we've been able to merge on last name because it uniquely identifies observations in our data. However, what if we also had data on Rep. Sheila Jackson Lee in our original dataframe? Let's add a row for her to `df_a`.

```{r}
df_a <- tibble(
  LastName = c("Lee"),
  FirstName = c("Sheila Jackson"),
  Party = c("D"),
  State = c("TX")
  ) %>%
  bind_rows(df_a, .)
```

A quick sidenote -- we used a trick here in our pipeline. Notice the period . in `bind_rows()`? In a pipeline, if you want to feed the results above into an argument *other* than the first argument, you can put a period in the place you want the upstream results to be used. In this example, we wanted to use `bind_rows()` to combine our original dataframe with the new Sheila Jackson Lee row, and we wanted that new row we created to be placed after the original dataframe. We accomplished that by using the period after the name of the original dataframe to specify the order.

With this modified dataframe in hand, what happens if we use our `full_join()` now? 

```{r}
full_join(df_a, df_b, by = "LastName")
```

Notice that the DW-NOMINATE value of -0.68 from Dataframe B has been assigned to both Barbara Lee as well as Sheila Jackson Lee, since the key variable LastName in Dataframe B matches both rows in dataframe A. Sometimes that might be what we want to happen. For example, imagine we had some data on survey respondents, where every row was an individual respondent. Suppose we wanted to merge information about their representative to this dataframe. There might be several respondents who all live in the same district, and, if our key is some form of district ID, we'd want to add on the same data about that representative to each row in the survey dataframe. 

In this case though, we're assigning the same DW-NOMINATE score incorrectly to one of the two Lee's. Let's modify dataframe B by adding representative's first names as well, so we can distinguish between the two similarly named politicians. 

```{r}
df_b <- tibble(
  LastName = c("Schiff", "Pelosi", "Ocasio-Cortez", 
               "Lee", "Crenshaw", "McCarthy", "Gaetz", "Lee"),
  FirstName = c("Adam", "Nancy", "Alexandria",
                "Barbara", "Dan", "Kevin", "Matt", "Sheila Jackson"),
  DWNom_Dim1 = c(-0.35, -0.49, -0.25, -0.68,
                 0.43, 0.46, 0.61, -0.46)
)
```

Let's try that merge again, only this time, we'll merge on two key variables -- last *and* first name.

```{r}
combined_df <- full_join(df_a, df_b, by = c("LastName", "FirstName"))
combined_df
```

We now have the correct DW-NOMINATE score for Sheila Jackson Lee!

For illustrative purposes, let's try that latter merge again, only this time, let's try merging only on last name again. What happens here?

```{r}
full_join(df_a, df_b, by = c("LastName"))
```

Two issues are quickly apparent. First, we have a `FirstName.x` and a `FirstName.y` column. Since `FirstName` is no longer a key variable, R assumes we want to add on each of these columns as data from each of the original dataframes. Since we can't have two columns with the same name in the same dataframe, R appends .x and .y to indicate which of the original dataframes each column comes from.

Second, since we have two Lee's in each dataframe now, all possible combinations are returned. We have Sheila Jackson and Barbara matched with each of the two DW-NOMINATE scores, since either could be the one we want to match (without using first name). This illustrates the dangers of merging based off of anything besides a uniquely identifying ID variable if we want a 1 to 1 match, like we do in this example. Sometimes commonly analyzed types of data, such as members of Congress, have such an ID that is used across datasets. For example, the Inter-university Consortium for Political and Social Research (ICPSR) gives a [unique ID number](https://www.icpsr.umich.edu/web/ICPSR/series/156) to each member of Congress that many other data sources include, making merging much easier. In the absence of such an ID, merges should be done with caution and results checked carefully. 

Finally, I want to discuss one last type of join that I find myself using for 90% or more of the merges I do in my work: the `left_join()` command. `left_join` works similarly to `inner_join` and `full_join`, only it keeps  all observations in Dataframe A, while returning only observations in Dataframe B with a key match in Dataframe B. This comes in very handy when you have a primary dataset (Dataframe A) for which you want to add one or a few variables from Dataframe B. With a `left_join()`, you're guaranteed not to lose any observations from Dataframe A, but will not get any additional observations from Dataframe B if there are many more than you actually care about.

The figure below displays a useful way of visualizing which observations each of these merging joins keeps.^[The `right_join()` command is identical to the `left_join()` command, all that differs is the positioning of the dataframes.] Don't forget, however, that with merging it's not just about which observations are kept and which are discarded, but what happens when there are duplicate matches. A good rule of thumb: prior to merging data, either 1) verify that the key variable uniquely identifies observations and there are no duplicates, 2) determine how many rows and columns you expect there to be after merging, and verify that you do indeed end up with that many rows and columns, or 3) do both. 

![A diagram for remembering join commands](Images/join-venn.png){width=80%}

# Filtering joins

The other types of joins that you should be aware of are what's known as **filtering joins**. These commands aren't meant to add variables from multiple datasets together. Rather, they're designed to either keep or exclude rows in one dataframe (hence the *filter* in the name) based on whether an observation is in a second dataframe. 

The first example of this, a `semi_join()`, keeps observations in Dataframe A if and only if there is a key match in Dataframe B. For example, suppose we have a dataset on members in the Congressional Black Caucus.

```{r}
cbc_members <- tibble(
  FirstName = c("Maxine", "James","Sheila Jackson",  "Barbara"),
  LastName = c("Waters", "Clyburn", "Lee", "Lee"),
  MemberSince = c(1991, 1993, 1995, 1998)
)
```

If we wanted to conduct an analysis on members of the Congressional Black Caucus using variables in our original dataframe, but we didn't need any other variables from the `cbc_members` dataframe, we could use `semi_join()`. The syntax would be as follows:

```{r}
semi_join(combined_df, cbc_members, by = c("FirstName", "LastName"))
```
What we get as a result is the rows of the original dataframe for members Barbara Lee and Sheila Jackson Lee, the only members of the Congressional Black Caucus in the data we had previously.

The `anti_join()` command accomplishes the exact opposite of the `semi_join()` command. Instead of keeping rows from Dataframe A with matches in Dataframe B, it returns only those rows without matches. For example, if we conduct an `anti_join()` using the same data and arguments as above, we would get the following:

```{r}
anti_join(combined_df, cbc_members, by = c("FirstName", "LastName"))
```
Thus we have all members of Congress in our original dataframe who are not in the Congressional Black Caucus. 

`anti_joins` can be useful for a purpose like this, in which we want to exclude certain observations from our data. More frequently, `anti_joins` are useful for diagnosing where you're missing data. For example, if you were collecting data for members of Congress in a dataset, and wanted to quickly determine if you were missing any members, you could download a dataset with the full set of Congressional members you're interested in and perform an `anti_join`, to see if there are any rows remaining after the `anti_join`. 

# Application: merging member information with contribution data

Let's examine a real world application of merging using `_join()` commands. We'll return to the FEC data from before, but instead of just looking at aggregate totals for candidates, we'll look at data on specific contributions. The file `Individual Contributions (House Representatives).Rda` contains data on every contribution reported to the FEC to an incumbent U.S. Representative running for reelection in 2020, from January 1st to election day.^[The data has been partially cleaned already, but was originally downloaded from the FEC website [here](https://www.fec.gov/files/bulk-downloads/2020/indiv20.zip).] We begin by loading the data into memory.   

```{r}
load("Data/Individual Contributions (House Representatives).Rda")

contribs %>% as_tibble()
```

As we can see after we load the data, we have a dataframe with approximately 2.5 million contributions and four variables. Each transaction (contribution) is uniquely identified with a transaction ID. We also have the ID of the Principal Campaign Committee (PCC) that the contribution was made to. Finally, we have the date the contribution was made and the dollar amount.

We want to associate each of these contributions with the member of Congress they were made to. Let's load our candidate dataframe again and think about how to merge these dataframes together. We'll filter our dataframe to only include incumbents running for the US House, since those are the candidates that we have contribution data for.

```{r}
cands <- read_delim("Data/webl20.txt",
                    delim = "|",
                    col_names = FALSE, 
                    trim_ws = TRUE,
                    escape_double = FALSE) %>%
  setNames(c("cand_id", "name", "incumbency_status", "party_code",
             "party_affil", "total_receipts", "transfers_from_cmte",
              "disbursements", "transfers_to_cmte", "beginning_cash",
              "ending_cash", "cand_contributions", "cand_loans",
              "other_loans", "cand_loan_repayments", "other_loan_repayments",
              "debts_owed", "indiv_contributions", "office_state",
              "district", "spec_election", "prim_election", "runoff_election",
              "general_election", "general_election_pct", "cmte_contributions",
              "party_contributions", "coverage_end", "individ_refunds",
              "cmte_refunds")) %>%
  filter(incumbency_status == "I", district != "00")

cands
```

Unfortunately, while we have the FEC's candidate ID in this dataset, we don't have the campaign committee ID to merge on. Luckily, a linkage file (candidate to committee) can be downloaded on the FEC's website. This isn't an uncommon situation when dealing with complex data -- frequently, to merge dataframes A and B, we will need a third dataframe C that can act as a "crosswalk" of sorts to go between them. Using similar code to above, we'll read in the linkage file that contains both a `cand_id` variable and a `pcc_id` variable.

```{r}
cand_cmte_link <- read_delim("Data/ccl.txt",
                  delim = "|", 
                  col_names = FALSE,
                  trim_ws = TRUE,
                  escape_double = FALSE) %>%
  setNames(c("cand_id", "cand_election_yr",
             "fec_election_year", "pcc_id",
             "cmte_type", "cmte_designation", "linkage_id")) 
```

The simplest way to tackle this problem is to first use a `_join()` command to add the `pcc_id` variable to the `cands` dataframe, then second, to add the candidate variables we care about to the `contribs` dataframe, merging on the (now shared) `pcc_id` variable as the key. The next question to ask ourselves is the type of join to use. For the merging the candidate and committee data, I would recommend using a `left_join()`. We don't need a `full_join()` in this scenario because we don't care if there are additional committees not connected to incumbent Representatives We could use an `inner_join()`, since we're not going to be able to merge candidate information if there's not a match in the `cand_cmte_link`. However, it will be easier to evaluate if our merge was successful if we keep all rows from the original dataframe since, hopefully, we'll have a PCC ID for each House incumbent. A `left_join()` will ensure we don't lose any rows from the `cands` dataframe for non-matches.

We begin by taking the `cand_cmte_link` dataframe, select the candidate and PCC ID variables, and joining these variables to the original `cands` dataframe.

```{r}
cands <- cand_cmte_link %>% 
  select(c(cand_id, pcc_id)) %>%
  left_join(cands, .)

cands
```

If you were paying attention, you'll notice our cands dataframe went from have 428 rows to 526. Does this mean something went wrong? Not at all. Some candidates are associated with multiple committees (for example, a solo committee and a joint committee). We want to associate *all* contributions to *any* linked committee with that candidate, so it's good that we have a row of candidate information to merge for each committee. 

Hopefully we have at least one committee for each member. How can we confirm that? Well, we could see if we're missing any instance of the `pcc_id` variables, since `left_join()` will return an NA if there isn't a `cand_id` match in the linkage file. Let's check. 

```{r}
sum(is.na(cands$pcc_id))
```

We haven't matched everyone to a committee, but we're close. If we wanted to determine who our problem Representative is, we could use `filter()` in conjunction with the `is.na()` command to return the row of the missing `pcc_id`.

```{r}
filter(cands, is.na(pcc_id))
```
Bradley Walker is our problem member. At this point, in a real research project, I would do some sleuthing on the FEC website to try to determine why the PCC ID was missing. Perhaps it's just an error in the specific data we downloaded, and we could find it somewhere else. For the purposes of our workshop, let's proceed by moving on to step 2. Merging with the contribution dataframe. 

We'll use a similar procedure as before. First, we'll select the variables from the `cands` dataframe that we want to add to the contribution data. In this case, besides the `pcc_id` to use as our merge key, let's add the Representatives name, their party, state, and district. We'll again use a `left_join()` -- hopefully we won't be missing any PCC IDs, but the `left_join()` will allow us to evaluate this *ex ante*. 

```{r}
contribs <- cands %>%
  select(c(pcc_id, name, party_affil, office_state, district)) %>%
  left_join(contribs, .)
```

How did we do? Let's again check if we're missing any information that should have been merged on, such as candidate name.

```{r}
sum(is.na(contribs$name))
```

A perfect merge! Always a joy to see as a researcher. 

Before moving on, let's save the newly merged data as a new object. We'll return to this later. 

```{r}
library(fst)

write_fst(contribs, "Data/Individual Contributions (Merged).fst")
```

# Reshaping data with pivot commands


