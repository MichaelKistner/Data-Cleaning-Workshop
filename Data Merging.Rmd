---
title: "Data Transformation"
author: "Michael Kistner"
date: "May 16, 2022"
output: 
  html_document:
    toc: true
---

```{r echo=FALSE}
options(scipen = 999)
```

# Introduction

So far, we've been working with a single dataset at a time and modifying it in various ways. One of the most common tasks in data cleaning and management, however, is **merging** data -- combining data from two or more datasets into a single dataframe for analysis. In this notebook, we'll cover the family of `_join()` verbs from the **dplyr** package. Broadly speaking, these verbs can be classified into two categories: **mutating joins** (joins that add new variables to a dataset) and **filtering joins** (joins that filter rows according to the presence or absence of matches in a dataset). In addition to `_join()` commands, we'll also cover the subject of reshaping data using the `pivot_longer()` and `pivot_wider()` commands from the **tidyr** package, which is useful when the data is XXXXXXXXXXXX.

As before, let's load the **tidyverse** package and get started.

```{r}
library(tidyverse)
```

# Merging with _join() commands

Let's begin by creating a pair of small toy datasets to illustrate the logic of joins. Later on in the notebook we'll apply what we learn here to actual data. Suppose we have a dataset with details about members of Congress -- their first name, last name, their party, the state they're from, etc. Suppose we also have a separate dataset with information about the DW-NOMINATE scores for each member, representing their ideology on a scale that runs from approximately -1 (most liberal) to 1 (most conservative).^[A more detailed description of DW-NOMINATE scores and downloadable data can be found at [voteview.com](https://voteview.com/).] Let's call the first dataframe `df_a` (Dataframe A) and the second `df_b` (Dataframe B).
 
```{r}
df_a <- tibble(
  LastName = c("Pelosi", "McCarthy", "Ocasio-Cortez", 
               "Lee", "Crenshaw"),
  FirstName = c("Nancy", "Kevin", "Alexandria",
                "Barbara", "Dan"),
  Party = c("D", "R", "D", "D", "R"),
  State = c("CA", "CA", "NY", "CA", "TX")
)

df_b <- tibble(
  LastName = c("Schiff", "Pelosi", "Ocasio Cortez", 
               "Lee", "Crenshaw", "McCarthy", "Gaetz"),
  DWNom_Dim1 = c(-0.35, -0.49, -0.25, -0.68,
                 0.43, 0.46, 0.61)
)
```

With data this small, we could manually enter data from `df_b` into `df_a`, but with large datasets this quickly becomes impractical. Instead, we can use **dplyr**'s `_join()` commands to do the difficult work for us.

An important concept for all `_join()` commands is the idea of a **key**. A **key** variable identifies observations in each dataset. For example, in our dataframes, we could use `LastName` as the key variable to link observations across the two dataframes and combine them. 

There are some important details to know about using keys for merging. First, computers are literal machines. Keys have to match *exactly*. Spelling errors, different formatting, lower case vs. upper case -- any of these will result in the data with the non-matching keys not being merged. Second, not just the values of the key variable but the names of the key variable should be the same in each dataset. We need to tell the `_join()` commands what the name of the key variable is, and it should match in both dataframes.^[There actually is a way to get around this in the optional arguments of the `_join()` commands, but I find that it's usually easier to just make sure key variable names are identical before attempting to merge.] Third, if a single variable doesn't uniquely identify observations, multiple variables can be used. We'll come back to this last point in a bit.

Let's begin with the simplest version of the `_join()` commands, the `inner_join()`. An `inner_join()` merges two dataframes -- every column from dataframe A, and every column from dataframe B -- keeping only rows where there's a match between the key in dataframe A and dataframe B. This last fact is what makes the join and *inner* join. In set theoretic terms, it's the intersection of the two dataframes. Let's try combining our dataframes with an `inner_join()`.

```{r}
inner_join(df_a, df_b, by = "LastName")
```

What were the results? We now have a dataframe with all of the original variables in dataframe A (FirstName, Party, and State) along with the DW-NOMINATE scores for each representative. Notice, however, that we're missing some observations. First, (Adam) Schiff and (Matt) Gaetz are missing because even though they're in dataframe B, they're not in dataframe A. The `inner_join()` gets rid of these observations. 

Second, we're missing Alexandria Ocasio-Cortez even though she's in both datasets. If you take a look, you'll realize that the hyphen between AOC's last names is missing in her name in dataframe B. If we fix that, we'll get her data back in the merge.

```{r}
df_b <- mutate(df_b,
               LastName = ifelse(LastName == "Ocasio Cortez",
                                 "Ocasio-Cortez",
                                 LastName))

inner_join(df_a, df_b, by = "LastName")
```
Now that the name matches, the merge works as expected. 

Rarely in practice do we (or should we) use `inner_join()`, however. The tendency for `inner_join()` to throw away data when an exact match in the key variable isn't found means that we're likely to get rid of data unknowningly. When datasets are large, it will be difficult to catch issues caused by minor spelling discrepancies, such as the above. An alternative is `full_join()`, which returns all rows from both Dataframe A and Dataframe B regardless of if there's a key match or not.^[Again, in set theoretic terms this would be the union of the two dataframes.] In the case that there isn't, the variables from the dataframe with the missing key match will be returned as NA. For our example, it would look something like this:

```{r}
full_join(df_a, df_b, by = "LastName")
```

In this example, we now know that observations for Adam Schiff and Matt Gaetz are missing from Dataframe A. If we weren't expecting that, we can then investigate. 

So far we've been able to merge on last name because it uniquely identifies observations in our data. However, what if we also had data on Rep. Sheila Jackson Lee in our original dataframe? Let's add a row for her to `df_a`.

```{r}
df_a <- tibble(
  LastName = c("Lee"),
  FirstName = c("Sheila Jackson"),
  Party = c("D"),
  State = c("TX")
  ) %>%
  bind_rows(df_a, .)
```

A quick sidenote -- we used a trick here in our pipeline. Notice the period . in `bind_rows()`? In a pipeline, if you want to feed the results above into an argument *other* than the first argument, you can put a period in the place you want the upstream results to be used. In this example, we wanted to use `bind_rows()` to combine our original dataframe with the new Sheila Jackson Lee row, and we wanted that new row we created to be placed after the original dataframe. We accomplished that by using the period after the name of the original dataframe to specify the order.

With this modified dataframe in hand, what happens if we use our `full_join()` now? 

```{r}
full_join(df_a, df_b, by = "LastName")
```

Notice that the DW-NOMINATE value of -0.68 from Dataframe B has been assigned to both Barbara Lee as well as Sheila Jackson Lee, since the key variable LastName in Dataframe B matches both rows in dataframe A. Sometimes that might be what we want to happen. For example, imagine we had some data on survey respondents, where every row was an individual respondent. Suppose we wanted to merge information about their representative to this dataframe. There might be several respondents who all live in the same district, and, if our key is some form of district ID, we'd want to add on the same data about that representative to each row in the survey dataframe. 

In this case though, we're assigning the same DW-NOMINATE score incorrectly to one of the two Lee's. Let's modify dataframe B by adding representative's first names as well, so we can distinguish between the two similarly named politicians. 

```{r}
df_b <- tibble(
  LastName = c("Schiff", "Pelosi", "Ocasio-Cortez", 
               "Lee", "Crenshaw", "McCarthy", "Gaetz", "Lee"),
  FirstName = c("Adam", "Nancy", "Alexandria",
                "Barbara", "Dan", "Kevin", "Matt", "Sheila Jackson"),
  DWNom_Dim1 = c(-0.35, -0.49, -0.25, -0.68,
                 0.43, 0.46, 0.61, -0.46)
)
```

Let's try that merge again, only this time, we'll merge on two key variables -- last *and* first name.

```{r}
full_join(df_a, df_b, by = c("LastName", "FirstName"))
```

We now have the correct DW-NOMINATE score for Sheila Jackson Lee!

For illustrative purposes, let's try that latter merge again, only this time, let's try merging only on last name again. What happens here?

```{r}
full_join(df_a, df_b, by = c("LastName"))
```

Two issues are quickly apparent. First, we have a `FirstName.x` and a `FirstName.y` column. Since `FirstName` is no longer a key variable, R assumes we want to add on each of these columns as data from each of the original dataframes. Since we can't have two columns with the same name in the same dataframe, R appends .x and .y to indicate which of the original dataframes each column comes from.

Second, since we have two Lee's in each dataframe now, all possible combinations are returned. We have Sheila Jackson and Barbara matched with each of the two DW-NOMINATE scores, since either could be the one we want to match (without using first name). This illustrates the dangers of merging based off of anything besides a uniquely identifying ID variable if we want a 1 to 1 match, like we do in this example. Sometimes commonly analyzed types of data, such as members of Congress, have such an ID that is used across datasets. For example, the Inter-university Consortium for Political and Social Research (ICPSR) gives a [unique ID number](https://www.icpsr.umich.edu/web/ICPSR/series/156) to each member of Congress that many other data sources include, making merging much easier. In the absence of such an ID, merges should be done with caution and results checked carefully. 

Finally, I want to discuss one last type of join that I find myself using for 90% or more of the merges I do in my work: the `left_join()` command. `left_join` works similarly to `inner_join` and `full_join`, only it keeps  all observations in Dataframe A, while returning only observations in Dataframe B with a key match in Dataframe B. This comes in very handy when you have a primary dataset (Dataframe A) for which you want to add one or a few variables from Dataframe B. With a `left_join()`, you're guaranteed not to lose any observations from Dataframe A, but will not get any additional observations from Dataframe B if there are many more than you actually care about.

The figure below displays a useful way of visualizing which observations each of these merging joins keeps.^[The `right_join()` command is identical to the `left_join()` command, all that differs is the positioning of the dataframes.] Don't forget, however, that with merging it's not just about which observations are kept and which are discarded, but what happens when there are duplicate matches. A good rule of thumb: prior to merging data, either 1) verify that the key variable uniquely identifies observations and there are no duplicates, 2) determine how many rows and columns you expect there to be after merging, and verify that you do indeed end up with that many rows and columns, or 3) do both. 

![A diagram for remembering join commands](Images/join-venn.png){width=80%}

# Filtering joins

# Application: contribution data


```{r}
cands <- read_delim("Data/webl20.txt",
                    delim = "|",
                    col_names = FALSE, 
                    trim_ws = TRUE,
                    escape_double = FALSE) %>%
  setNames(c("cand_id", "name", "incumbency_status", "party_code",
             "party_affil", "total_receipts", "transfers_from_cmte",
              "disbursements", "transfers_to_cmte", "beginning_cash",
              "ending_cash", "cand_contributions", "cand_loans",
              "other_loans", "cand_loan_repayments", "other_loan_repayments",
              "debts_owed", "indiv_contributions", "office_state",
              "district", "spec_election", "prim_election", "runoff_election",
              "general_election", "general_election_pct", "cmte_contributions",
              "party_contributions", "coverage_end", "individ_refunds",
              "cmte_refunds")) %>%
  filter(district != "00", incumbency_status == "I")
```

```{r}
cand_cmte_link <- read_delim("Data/ccl.txt",
                  delim = "|", escape_double = FALSE,
                  col_names = FALSE,
                  trim_ws = TRUE) %>%
  setNames(c("cand_id", "cand_election_yr",
             "fec_election_year", "pcc_id",
             "cmte_type", "cmte_designation", "linkage_id")) 
```

```{r}
load("Data/Individual Contributions.Rda")
```

```{r}
group_by(cand_cmte_link,
         cand_id) %>%
  summarize(num_cmtes = n()) %>%
  arrange(desc(num_cmtes))
```

```{r}
cands <- cand_cmte_link %>% 
  select(c(cand_id, pcc_id)) %>%
  left_join(cands, .)
```

```{r}
sum(is.na(cands$pcc_id))
```

```{r}
filter(cands, is.na(pcc_id))
```

```{r}
contribs <- cands %>%
  select(c(pcc_id, name, party_affil, office_state, district)) %>%
  left_join(contribs, .)
```

```{r}
contribs %>%
  group_by(name) %>%
  summarize(IndividualContribs = sum(transaction_amount)) %>%
  arrange(desc(IndividualContribs))
```

# Reshaping data with pivot commands


